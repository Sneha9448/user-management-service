package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"
	"user-management-service/graph/model"
	"user-management-service/internal/auth"
	emailpkg "user-management-service/internal/email"
	"user-management-service/internal/middleware"
	"user-management-service/internal/models"
	"user-management-service/internal/repository"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, name string, email string) (*models.User, error) {
	defer r.TrackExecutionTime(time.Now(), "CreateUser")
	userinfo := middleware.ForContext(ctx)
	if userinfo == nil {
		return nil, errors.New("access denied: authentication required")
	}

	user := &models.User{
		Name:  name,
		Email: email,
	}
	if err := repository.CreateUser(user); err != nil {
		return nil, err
	}
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, name string, email string) (*models.User, error) {
	defer r.TrackExecutionTime(time.Now(), "UpdateUser")
	userinfo := middleware.ForContext(ctx)
	if userinfo == nil {
		return nil, errors.New("access denied: authentication required")
	}

	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, errors.New("invalid user ID format")
	}

	user := &models.User{
		ID:    idInt,
		Name:  name,
		Email: email,
	}

	if err := repository.UpdateUser(user); err != nil {
		return nil, err
	}
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	defer r.TrackExecutionTime(time.Now(), "DeleteUser")
	userinfo := middleware.ForContext(ctx)
	if userinfo == nil {
		return false, errors.New("access denied: authentication required")
	}

	idInt, err := strconv.Atoi(id)
	if err != nil {
		return false, errors.New("invalid user ID format")
	}

	if err := repository.DeleteUser(idInt); err != nil {
		return false, err
	}
	return true, nil
}

// LoginWithGoogle is the resolver for the loginWithGoogle field.
func (r *mutationResolver) LoginWithGoogle(ctx context.Context, idToken string) (*model.AuthResponse, error) {
	defer r.TrackExecutionTime(time.Now(), "LoginWithGoogle")

	// 1. Verify Google Token
	email, err := auth.VerifyGoogleToken(ctx, idToken, "") // Client ID empty for mock/demo
	if err != nil {
		return nil, fmt.Errorf("google auth failed: %v", err)
	}

	// 2. Find or Create User by Email
	user, err := repository.GetUserByEmail(email)
	if err != nil {
		// If user doesn't exist, create a new one
		user = &models.User{
			Name:  "Google User", // Fallback name
			Email: email,
		}
		if err := repository.CreateUser(user); err != nil {
			return nil, fmt.Errorf("failed to create user: %v", err)
		}
	}

	// 3. Generate JWT
	token, err := auth.GenerateJWT(strconv.Itoa(user.ID), user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate session: %v", err)
	}

	return &model.AuthResponse{
		Token: token,
		User: &models.User{
			ID:    user.ID,
			Name:  user.Name,
			Email: user.Email,
		},
	}, nil
}

// RequestOtp is the resolver for the requestOtp field.
func (r *mutationResolver) RequestOtp(ctx context.Context, email string) (*string, error) {
	defer r.TrackExecutionTime(time.Now(), "RequestOtp")

	// 1. Generate 6-digit OTP
	otp, err := auth.GenerateOTP()
	if err != nil {
		return nil, fmt.Errorf("failed to generate OTP: %v", err)
	}

	// 2. Store OTP in DB (10 min expiry)
	expiresAt := time.Now().Add(10 * time.Minute)
	otpModel := &models.OTP{
		Email:     email,
		OTP:       otp,
		ExpiresAt: expiresAt,
	}

	if err := repository.SaveOTP(otpModel); err != nil {
		return nil, fmt.Errorf("failed to save OTP: %v", err)
	}

	// 3. Send Email
	if err := emailpkg.SendOTPEmail(email, otp); err != nil {
		log.Printf("Email sending failed (but OTP saved): %v", err)
		// We don't return error here if we want the user to still be able to use the OTP
		// but for security/ux we might want to know.
	}

	successMsg := "OTP sent successfully"
	return &successMsg, nil
}

// VerifyOtp is the resolver for the verifyOtp field.
func (r *mutationResolver) VerifyOtp(ctx context.Context, email string, otp string) (*model.AuthResponse, error) {
	defer r.TrackExecutionTime(time.Now(), "VerifyOtp")

	// 1. Get latest OTP from DB
	latestOtp, err := repository.GetLatestOTP(email)
	if err != nil {
		return nil, fmt.Errorf("failed to check OTP: %v", err)
	}

	if latestOtp == nil {
		return nil, errors.New("no OTP request found for this email")
	}

	// 2. Validate OTP
	if latestOtp.IsUsed {
		return nil, errors.New("OTP has already been used")
	}

	if time.Now().After(latestOtp.ExpiresAt) {
		return nil, errors.New("OTP has expired")
	}

	if latestOtp.AttemptCount >= 3 {
		return nil, errors.New("maximum verification attempts exceeded")
	}

	if latestOtp.OTP != otp {
		repository.IncrementOTPAttempts(latestOtp.ID)
		return nil, errors.New("invalid OTP")
	}

	// 3. Mark as Used
	if err := repository.MarkOTPAsUsed(latestOtp.ID); err != nil {
		return nil, fmt.Errorf("failed to finalize OTP: %v", err)
	}

	// 4. Find or Create User
	user, err := repository.GetUserByEmail(email)
	if err != nil {
		// Create user if not exists
		user = &models.User{
			Name:  "OTP User",
			Email: email,
		}
		if err := repository.CreateUser(user); err != nil {
			return nil, fmt.Errorf("failed to create user: %v", err)
		}
	}

	// 5. Generate JWT
	token, err := auth.GenerateJWT(strconv.Itoa(user.ID), user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate session: %v", err)
	}

	return &model.AuthResponse{
		Token: token,
		User: &models.User{
			ID:    user.ID,
			Name:  user.Name,
			Email: user.Email,
		},
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	defer r.TrackExecutionTime(time.Now(), "Users")
	return repository.GetAllUsers()
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
	defer r.TrackExecutionTime(time.Now(), "User")
	idInt, err := strconv.Atoi(id)
	if err != nil {
		return nil, errors.New("invalid user ID format")
	}
	return repository.GetUserByID(idInt)
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	defer r.TrackExecutionTime(time.Now(), "Me")
	userinfo := middleware.ForContext(ctx)
	if userinfo == nil {
		return nil, nil // Return null if not authenticated
	}

	idInt, _ := strconv.Atoi(userinfo.ID)
	return repository.GetUserByID(idInt)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
